// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchUpdateMediaOrder = `-- name: BatchUpdateMediaOrder :exec
UPDATE media
SET media_order = data.new_order
FROM (
    VALUES 
      -- Format: (media_id, new_order)
      ($1::uuid, $2::int),
      ($3::uuid, $4::int)
      -- Add more tuples as needed...
) AS data(media_id, new_order)
WHERE media.media_id = data.media_id
`

type BatchUpdateMediaOrderParams struct {
	Media1ID    pgtype.UUID
	Media1Order int32
	Media2ID    pgtype.UUID
	Media2Order int32
}

func (q *Queries) BatchUpdateMediaOrder(ctx context.Context, arg BatchUpdateMediaOrderParams) error {
	_, err := q.db.Exec(ctx, batchUpdateMediaOrder,
		arg.Media1ID,
		arg.Media1Order,
		arg.Media2ID,
		arg.Media2Order,
	)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media
WHERE media_id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, mediaID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMedia, mediaID)
	return err
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT media_id, content_id, media_type, media_url, media_caption, media_order
FROM media
WHERE media_id = $1
`

func (q *Queries) GetMediaByID(ctx context.Context, mediaID pgtype.UUID) (Medium, error) {
	row := q.db.QueryRow(ctx, getMediaByID, mediaID)
	var i Medium
	err := row.Scan(
		&i.MediaID,
		&i.ContentID,
		&i.MediaType,
		&i.MediaUrl,
		&i.MediaCaption,
		&i.MediaOrder,
	)
	return i, err
}

const insertMedia = `-- name: InsertMedia :one
INSERT INTO media (content_id, media_type, media_url, media_caption, media_order)
VALUES ($1, $2, $3, $4, $5)
RETURNING media_id, content_id, media_type, media_url, media_caption, media_order
`

type InsertMediaParams struct {
	ContentID    pgtype.UUID
	MediaType    string
	MediaUrl     string
	MediaCaption string
	MediaOrder   int32
}

func (q *Queries) InsertMedia(ctx context.Context, arg InsertMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, insertMedia,
		arg.ContentID,
		arg.MediaType,
		arg.MediaUrl,
		arg.MediaCaption,
		arg.MediaOrder,
	)
	var i Medium
	err := row.Scan(
		&i.MediaID,
		&i.ContentID,
		&i.MediaType,
		&i.MediaUrl,
		&i.MediaCaption,
		&i.MediaOrder,
	)
	return i, err
}

const listMediaForContent = `-- name: ListMediaForContent :many
SELECT media_id, content_id, media_type, media_url, media_caption, media_order
FROM media
WHERE content_id = $1
ORDER BY media_order ASC
`

func (q *Queries) ListMediaForContent(ctx context.Context, contentID pgtype.UUID) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMediaForContent, contentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.MediaID,
			&i.ContentID,
			&i.MediaType,
			&i.MediaUrl,
			&i.MediaCaption,
			&i.MediaOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMedia = `-- name: UpdateMedia :one
UPDATE media
SET media_url = $1,
    media_caption = $2,
    media_order = $3
WHERE media_id = $4
RETURNING media_id, content_id, media_type, media_url, media_caption, media_order
`

type UpdateMediaParams struct {
	MediaUrl     string
	MediaCaption string
	MediaOrder   int32
	MediaID      pgtype.UUID
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, updateMedia,
		arg.MediaUrl,
		arg.MediaCaption,
		arg.MediaOrder,
		arg.MediaID,
	)
	var i Medium
	err := row.Scan(
		&i.MediaID,
		&i.ContentID,
		&i.MediaType,
		&i.MediaUrl,
		&i.MediaCaption,
		&i.MediaOrder,
	)
	return i, err
}
